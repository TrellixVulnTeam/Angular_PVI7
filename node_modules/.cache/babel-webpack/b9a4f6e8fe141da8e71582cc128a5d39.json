{"ast":null,"code":"import * as i0 from '@angular/core';\nimport { InjectionToken, PLATFORM_ID, Injectable, Inject, NgModule } from '@angular/core';\nimport { isPlatformBrowser, CommonModule } from '@angular/common';\nimport { __awaiter } from 'tslib';\nimport { Observable, from, combineLatest, Subject } from 'rxjs';\nimport { take } from 'rxjs/operators';\n\nfunction openDatabase(indexedDB, dbName, version, upgradeCallback) {\n  return new Promise((resolve, reject) => {\n    if (!indexedDB) {\n      reject('IndexedDB not available');\n    }\n\n    const request = indexedDB.open(dbName, version);\n    let db;\n\n    request.onsuccess = event => {\n      db = request.result;\n      resolve(db);\n    };\n\n    request.onerror = event => {\n      reject(`IndexedDB error: ${request.error}`);\n    };\n\n    if (typeof upgradeCallback === 'function') {\n      request.onupgradeneeded = event => {\n        upgradeCallback(event, db);\n      };\n    }\n  });\n}\n\nfunction CreateObjectStore(indexedDB, dbName, version, storeSchemas, migrationFactory) {\n  if (!indexedDB) {\n    return;\n  }\n\n  const request = indexedDB.open(dbName, version);\n\n  request.onupgradeneeded = event => {\n    const database = event.target.result;\n    storeSchemas.forEach(storeSchema => {\n      if (!database.objectStoreNames.contains(storeSchema.store)) {\n        const objectStore = database.createObjectStore(storeSchema.store, storeSchema.storeConfig);\n        storeSchema.storeSchema.forEach(schema => {\n          objectStore.createIndex(schema.name, schema.keypath, schema.options);\n        });\n      }\n    });\n    const storeMigrations = migrationFactory && migrationFactory();\n\n    if (storeMigrations) {\n      Object.keys(storeMigrations).map(k => parseInt(k, 10)).filter(v => v > event.oldVersion).sort((a, b) => a - b).forEach(v => {\n        storeMigrations[v](database, request.transaction);\n      });\n    }\n\n    database.close();\n  };\n\n  request.onsuccess = e => {\n    e.target.result.close();\n  };\n}\n\nfunction DeleteObjectStore(dbName, version, storeName) {\n  if (!dbName || !version || !storeName) {\n    throw Error('Params: \"dbName\", \"version\", \"storeName\" are mandatory.');\n  }\n\n  return new Observable(obs => {\n    try {\n      const newVersion = version + 1;\n      const request = indexedDB.open(dbName, newVersion);\n\n      request.onupgradeneeded = event => {\n        const database = event.target.result;\n        database.deleteObjectStore(storeName);\n        database.close();\n        console.log('onupgradeneeded');\n        obs.next(true);\n        obs.complete();\n      };\n\n      request.onerror = e => obs.error(e);\n    } catch (error) {\n      obs.error(error);\n    }\n  });\n}\n\nfunction validateStoreName(db, storeName) {\n  return db.objectStoreNames.contains(storeName);\n}\n\nfunction validateBeforeTransaction(db, storeName, reject) {\n  if (!db) {\n    reject('You need to use the openDatabase function to create a database before you query it!');\n  }\n\n  if (!validateStoreName(db, storeName)) {\n    reject(`objectStore does not exists: ${storeName}`);\n  }\n}\n\nfunction createTransaction(db, options) {\n  const trans = db.transaction(options.storeName, options.dbMode);\n  trans.onerror = options.error;\n  trans.onabort = options.abort;\n  return trans;\n}\n\nfunction optionsGenerator(type, storeName, reject, resolve) {\n  return {\n    storeName,\n    dbMode: type,\n    error: e => {\n      reject(e);\n    },\n    abort: e => {\n      reject(e);\n    }\n  };\n}\n\nvar DBMode;\n\n(function (DBMode) {\n  DBMode[\"readonly\"] = \"readonly\";\n  DBMode[\"readwrite\"] = \"readwrite\";\n})(DBMode || (DBMode = {}));\n\nconst CONFIG_TOKEN = new InjectionToken(null);\n\nclass NgxIndexedDBService {\n  constructor(dbConfig, platformId) {\n    this.dbConfig = dbConfig;\n    this.platformId = platformId;\n\n    if (!dbConfig.name) {\n      throw new Error('NgxIndexedDB: Please, provide the dbName in the configuration');\n    }\n\n    if (!dbConfig.version) {\n      throw new Error('NgxIndexedDB: Please, provide the db version in the configuration');\n    }\n\n    this.isBrowser = isPlatformBrowser(this.platformId);\n\n    if (this.isBrowser) {\n      this.indexedDB = window.indexedDB || window.mozIndexedDB || window.webkitIndexedDB || window.msIndexedDB;\n      CreateObjectStore(this.indexedDB, dbConfig.name, dbConfig.version, dbConfig.objectStoresMeta, dbConfig.migrationFactory);\n      openDatabase(this.indexedDB, dbConfig.name).then(db => {\n        if (db.version !== dbConfig.version) {\n          if (process.env.NODE_ENV !== 'production') {\n            console.warn(`\n            Your DB Config doesn't match the most recent version of the DB with name ${this.dbConfig.name}, please update it\n            DB current version: ${db.version};\n            Your configuration: ${dbConfig.version};\n            `);\n            console.warn(`Using latest version ${db.version}`);\n          }\n\n          this.dbConfig.version = db.version;\n        }\n      });\n    }\n  }\n  /**\n   * Allows to crate a new object store ad-hoc\n   * @param storeName The name of the store to be created\n   * @param migrationFactory The migration factory if exists\n   */\n\n\n  createObjectStore(storeSchema, migrationFactory) {\n    const storeSchemas = [storeSchema];\n    CreateObjectStore(this.indexedDB, this.dbConfig.name, ++this.dbConfig.version, storeSchemas, migrationFactory);\n  }\n  /**\n   * Adds new entry in the store and returns its key\n   * @param storeName The name of the store to add the item\n   * @param value The entry to be added\n   * @param key The optional key for the entry\n   */\n\n\n  add(storeName, value, key) {\n    return new Observable(obs => {\n      openDatabase(this.indexedDB, this.dbConfig.name, this.dbConfig.version).then(db => {\n        const transaction = createTransaction(db, optionsGenerator(DBMode.readwrite, storeName, obs.error));\n        const objectStore = transaction.objectStore(storeName);\n        const request = Boolean(key) ? objectStore.add(value, key) : objectStore.add(value);\n\n        request.onsuccess = evt => __awaiter(this, void 0, void 0, function* () {\n          const result = evt.target.result;\n          const getRequest = objectStore.get(result);\n\n          getRequest.onsuccess = event => {\n            obs.next(event.target.result);\n            obs.complete();\n          };\n        });\n      }).catch(error => obs.error(error));\n    });\n  }\n  /**\n   * Adds new entries in the store and returns its key\n   * @param storeName The name of the store to add the item\n   * @param values The entries to be added containing optional key attribute\n   */\n\n\n  bulkAdd(storeName, values) {\n    const promises = new Promise((resolve, reject) => {\n      openDatabase(this.indexedDB, this.dbConfig.name, this.dbConfig.version).then(db => {\n        const transaction = createTransaction(db, optionsGenerator(DBMode.readwrite, storeName, resolve, reject));\n        const objectStore = transaction.objectStore(storeName);\n        const results = values.map(value => {\n          return new Promise((resolve1, reject1) => {\n            const key = value.key;\n            delete value.key;\n            const request = Boolean(key) ? objectStore.add(value, key) : objectStore.add(value);\n\n            request.onsuccess = evt => {\n              const result = evt.target.result;\n              resolve1(result);\n            };\n          });\n        });\n        resolve(Promise.all(results));\n      }).catch(reason => reject(reason));\n    });\n    return from(promises);\n  }\n  /**\n   * Delete entries in the store and returns current entries in the store\n   * @param storeName The name of the store to add the item\n   * @param keys The keys to be deleted\n   */\n\n\n  bulkDelete(storeName, keys) {\n    const promises = keys.map(key => {\n      return new Promise((resolve, reject) => {\n        openDatabase(this.indexedDB, this.dbConfig.name, this.dbConfig.version).then(db => {\n          const transaction = createTransaction(db, optionsGenerator(DBMode.readwrite, storeName, reject, resolve));\n          const objectStore = transaction.objectStore(storeName);\n          objectStore.delete(key);\n\n          transaction.oncomplete = () => {\n            this.getAll(storeName).pipe(take(1)).subscribe(newValues => {\n              resolve(newValues);\n            });\n          };\n        }).catch(reason => reject(reason));\n      });\n    });\n    return from(Promise.all(promises));\n  }\n  /**\n   * Returns entry by key.\n   * @param storeName The name of the store to query\n   * @param key The entry key\n   */\n\n\n  getByKey(storeName, key) {\n    return new Observable(obs => {\n      openDatabase(this.indexedDB, this.dbConfig.name, this.dbConfig.version).then(db => {\n        const transaction = createTransaction(db, optionsGenerator(DBMode.readonly, storeName, obs.error));\n        const objectStore = transaction.objectStore(storeName);\n        const request = objectStore.get(key);\n\n        request.onsuccess = event => {\n          obs.next(event.target.result);\n          obs.complete();\n        };\n\n        request.onerror = event => {\n          obs.error(event);\n        };\n      }).catch(error => obs.error(error));\n    });\n  }\n  /**\n   * Retrieve multiple entries in the store\n   * @param storeName The name of the store to retrieve the items\n   * @param keys The ids entries to be retrieve\n   */\n\n\n  bulkGet(storeName, keys) {\n    const observables = keys.map(key => this.getByKey(storeName, key));\n    return new Observable(obs => {\n      combineLatest(observables).subscribe(values => {\n        obs.next(values);\n        obs.complete();\n      });\n    });\n  }\n  /**\n   * Returns entry by id.\n   * @param storeName The name of the store to query\n   * @param id The entry id\n   */\n\n\n  getByID(storeName, id) {\n    return new Observable(obs => {\n      openDatabase(this.indexedDB, this.dbConfig.name, this.dbConfig.version).then(db => {\n        validateBeforeTransaction(db, storeName, obs.error);\n        const transaction = createTransaction(db, optionsGenerator(DBMode.readonly, storeName, obs.error, obs.next));\n        const objectStore = transaction.objectStore(storeName);\n        const request = objectStore.get(id);\n\n        request.onsuccess = event => {\n          obs.next(event.target.result);\n        };\n      }).catch(error => obs.error(error));\n    });\n  }\n  /**\n   * Returns entry by index.\n   * @param storeName The name of the store to query\n   * @param indexName The index name to filter\n   * @param key The entry key.\n   */\n\n\n  getByIndex(storeName, indexName, key) {\n    return new Observable(obs => {\n      openDatabase(this.indexedDB, this.dbConfig.name, this.dbConfig.version).then(db => {\n        validateBeforeTransaction(db, storeName, obs.error);\n        const transaction = createTransaction(db, optionsGenerator(DBMode.readonly, storeName, obs.error));\n        const objectStore = transaction.objectStore(storeName);\n        const index = objectStore.index(indexName);\n        const request = index.get(key);\n\n        request.onsuccess = event => {\n          obs.next(event.target.result);\n          obs.complete();\n        };\n      }).catch(reason => obs.error(reason));\n    });\n  }\n  /**\n   * Return all elements from one store\n   * @param storeName The name of the store to select the items\n   */\n\n\n  getAll(storeName) {\n    return new Observable(obs => {\n      openDatabase(this.indexedDB, this.dbConfig.name, this.dbConfig.version).then(db => {\n        validateBeforeTransaction(db, storeName, obs.error);\n        const transaction = createTransaction(db, optionsGenerator(DBMode.readonly, storeName, obs.error, obs.next));\n        const objectStore = transaction.objectStore(storeName);\n        const request = objectStore.getAll();\n\n        request.onerror = evt => {\n          obs.error(evt);\n        };\n\n        request.onsuccess = ({\n          target: {\n            result: ResultAll\n          }\n        }) => {\n          obs.next(ResultAll);\n          obs.complete();\n        };\n      }).catch(error => obs.error(error));\n    });\n  }\n  /**\n   * Returns all items from the store after update.\n   * @param storeName The name of the store to update\n   * @param value The new value for the entry\n   * @param key The key of the entry to update if exists\n   */\n\n\n  update(storeName, value, key) {\n    return new Observable(obs => {\n      openDatabase(this.indexedDB, this.dbConfig.name, this.dbConfig.version).then(db => {\n        validateBeforeTransaction(db, storeName, obs.error);\n        const transaction = createTransaction(db, optionsGenerator(DBMode.readwrite, storeName, obs.error));\n        const objectStore = transaction.objectStore(storeName);\n\n        transaction.oncomplete = () => {\n          this.getAll(storeName).pipe(take(1)).subscribe(newValues => {\n            obs.next(newValues);\n            obs.complete();\n          });\n        };\n\n        key ? objectStore.put(value, key) : objectStore.put(value);\n      }).catch(reason => obs.error(reason));\n    });\n  }\n  /**\n   * Returns the item you updated from the store after the update.\n   * @param storeName The name of the store to update\n   * @param value The new value for the entry\n   * @param key The key of the entry to update\n   */\n\n\n  updateByKey(storeName, value, key) {\n    return new Observable(obs => {\n      openDatabase(this.indexedDB, this.dbConfig.name, this.dbConfig.version).then(db => {\n        validateBeforeTransaction(db, storeName, obs.error);\n        const transaction = createTransaction(db, optionsGenerator(DBMode.readwrite, storeName, obs.error));\n        const objectStore = transaction.objectStore(storeName);\n\n        transaction.oncomplete = () => {\n          this.getByKey(storeName, key).pipe(take(1)).subscribe(newValue => {\n            obs.next(newValue);\n            obs.complete();\n          });\n        };\n\n        objectStore.put(value, key);\n      }).catch(reason => obs.error(reason));\n    });\n  }\n  /**\n   * Returns all items from the store after delete.\n   * @param storeName The name of the store to have the entry deleted\n   * @param key The key of the entry to be deleted\n   */\n\n\n  delete(storeName, key) {\n    return new Observable(obs => {\n      openDatabase(this.indexedDB, this.dbConfig.name, this.dbConfig.version).then(db => {\n        validateBeforeTransaction(db, storeName, obs.error);\n        const transaction = createTransaction(db, optionsGenerator(DBMode.readwrite, storeName, obs.error));\n        const objectStore = transaction.objectStore(storeName);\n        objectStore.delete(key);\n\n        transaction.oncomplete = () => {\n          this.getAll(storeName).pipe(take(1)).subscribe(newValues => {\n            obs.next(newValues);\n            obs.complete();\n          });\n        };\n      }).catch(reason => obs.error(reason));\n    });\n  }\n  /**\n   * Returns true from the store after a successful delete.\n   * @param storeName The name of the store to have the entry deleted\n   * @param key The key of the entry to be deleted\n   */\n\n\n  deleteByKey(storeName, key) {\n    return new Observable(obs => {\n      openDatabase(this.indexedDB, this.dbConfig.name, this.dbConfig.version).then(db => {\n        validateBeforeTransaction(db, storeName, obs.error);\n        const transaction = createTransaction(db, optionsGenerator(DBMode.readwrite, storeName, obs.error));\n        const objectStore = transaction.objectStore(storeName);\n\n        transaction.oncomplete = () => {\n          obs.next(true);\n          obs.complete();\n        };\n\n        objectStore.delete(key);\n      }).catch(reason => obs.error(reason));\n    });\n  }\n  /**\n   * Returns true if successfully delete all entries from the store.\n   * @param storeName The name of the store to have the entries deleted\n   */\n\n\n  clear(storeName) {\n    return new Observable(obs => {\n      openDatabase(this.indexedDB, this.dbConfig.name, this.dbConfig.version).then(db => {\n        validateBeforeTransaction(db, storeName, obs.error);\n        const transaction = createTransaction(db, optionsGenerator(DBMode.readwrite, storeName, obs.error));\n        const objectStore = transaction.objectStore(storeName);\n        objectStore.clear();\n\n        transaction.oncomplete = () => {\n          obs.next(true);\n          obs.complete();\n        };\n      }).catch(reason => obs.error(reason));\n    });\n  }\n  /**\n   * Returns true if successfully delete the DB.\n   */\n\n\n  deleteDatabase() {\n    return new Observable(obs => {\n      openDatabase(this.indexedDB, this.dbConfig.name, this.dbConfig.version).then(db => __awaiter(this, void 0, void 0, function* () {\n        yield db.close();\n        const deleteDBRequest = this.indexedDB.deleteDatabase(this.dbConfig.name);\n\n        deleteDBRequest.onsuccess = () => {\n          obs.next(true);\n          obs.complete();\n        };\n\n        deleteDBRequest.onerror = error => obs.error(error);\n\n        deleteDBRequest.onblocked = () => {\n          throw new Error(`Unable to delete database because it's blocked`);\n        };\n      })).catch(error => obs.error(error));\n    });\n  }\n  /**\n   * Returns the open cursor event\n   * @param storeName The name of the store to have the entries deleted\n   * @param keyRange The key range which the cursor should be open on\n   */\n\n\n  openCursor(storeName, keyRange) {\n    return new Observable(obs => {\n      openDatabase(this.indexedDB, this.dbConfig.name, this.dbConfig.version).then(db => {\n        validateBeforeTransaction(db, storeName, obs.error);\n        const transaction = createTransaction(db, optionsGenerator(DBMode.readonly, storeName, obs.error));\n        const objectStore = transaction.objectStore(storeName);\n        const request = keyRange === undefined ? objectStore.openCursor() : objectStore.openCursor(keyRange);\n\n        request.onsuccess = event => {\n          obs.next(event);\n          obs.complete();\n        };\n      }).catch(reason => obs.error(reason));\n    });\n  }\n  /**\n   * Open a cursor by index filter.\n   * @param storeName The name of the store to query.\n   * @param indexName The index name to filter.\n   * @param keyRange The range value and criteria to apply on the index.\n   */\n\n\n  openCursorByIndex(storeName, indexName, keyRange, mode = DBMode.readonly) {\n    const obs = new Subject();\n    openDatabase(this.indexedDB, this.dbConfig.name, this.dbConfig.version).then(db => {\n      validateBeforeTransaction(db, storeName, reason => {\n        obs.error(reason);\n      });\n      const transaction = createTransaction(db, optionsGenerator(mode, storeName, reason => {\n        obs.error(reason);\n      }, () => {\n        obs.next();\n      }));\n      const objectStore = transaction.objectStore(storeName);\n      const index = objectStore.index(indexName);\n      const request = index.openCursor(keyRange);\n\n      request.onsuccess = event => {\n        obs.next(event);\n      };\n    }).catch(reason => obs.error(reason));\n    return obs;\n  }\n  /**\n   * Returns all items by an index.\n   * @param storeName The name of the store to query\n   * @param indexName The index name to filter\n   * @param keyRange  The range value and criteria to apply on the index.\n   */\n\n\n  getAllByIndex(storeName, indexName, keyRange) {\n    const data = [];\n    return new Observable(obs => {\n      openDatabase(this.indexedDB, this.dbConfig.name, this.dbConfig.version).then(db => {\n        validateBeforeTransaction(db, storeName, obs.error);\n        const transaction = createTransaction(db, optionsGenerator(DBMode.readonly, storeName, obs.error));\n        const objectStore = transaction.objectStore(storeName);\n        const index = objectStore.index(indexName);\n        const request = index.openCursor(keyRange);\n\n        request.onsuccess = event => {\n          const cursor = event.target.result;\n\n          if (cursor) {\n            data.push(cursor.value);\n            cursor.continue();\n          } else {\n            obs.next(data);\n            obs.complete();\n          }\n        };\n      }).catch(reason => obs.error(reason));\n    });\n  }\n  /**\n   * Returns all primary keys by an index.\n   * @param storeName The name of the store to query\n   * @param indexName The index name to filter\n   * @param keyRange  The range value and criteria to apply on the index.\n   */\n\n\n  getAllKeysByIndex(storeName, indexName, keyRange) {\n    const data = [];\n    return new Observable(obs => {\n      openDatabase(this.indexedDB, this.dbConfig.name, this.dbConfig.version).then(db => {\n        validateBeforeTransaction(db, storeName, obs.error);\n        const transaction = createTransaction(db, optionsGenerator(DBMode.readonly, storeName, obs.error));\n        const objectStore = transaction.objectStore(storeName);\n        const index = objectStore.index(indexName);\n        const request = index.openKeyCursor(keyRange);\n\n        request.onsuccess = event => {\n          const cursor = event.target.result;\n\n          if (cursor) {\n            data.push({\n              primaryKey: cursor.primaryKey,\n              key: cursor.key\n            });\n            cursor.continue();\n          } else {\n            obs.next(data);\n            obs.complete();\n          }\n        };\n      }).catch(reason => obs.error(reason));\n    });\n  }\n  /**\n   * Returns the number of rows in a store.\n   * @param storeName The name of the store to query\n   * @param keyRange  The range value and criteria to apply.\n   */\n\n\n  count(storeName, keyRange) {\n    return new Observable(obs => {\n      openDatabase(this.indexedDB, this.dbConfig.name, this.dbConfig.version).then(db => {\n        validateBeforeTransaction(db, storeName, obs.error);\n        const transaction = createTransaction(db, optionsGenerator(DBMode.readonly, storeName, obs.error));\n        const objectStore = transaction.objectStore(storeName);\n        const request = objectStore.count(keyRange);\n\n        request.onerror = e => obs.error(e);\n\n        request.onsuccess = e => {\n          obs.next(e.target.result);\n          obs.complete();\n        };\n      }).catch(reason => obs.error(reason));\n    });\n  }\n  /**\n   * Delete the store by name.\n   * @param storeName The name of the store to query\n   */\n\n\n  deleteObjectStore(storeName) {\n    return DeleteObjectStore(this.dbConfig.name, ++this.dbConfig.version, storeName);\n  }\n\n}\n\nNgxIndexedDBService.ɵfac = function NgxIndexedDBService_Factory(t) {\n  return new (t || NgxIndexedDBService)(i0.ɵɵinject(CONFIG_TOKEN), i0.ɵɵinject(PLATFORM_ID));\n};\n\nNgxIndexedDBService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: NgxIndexedDBService,\n  factory: NgxIndexedDBService.ɵfac\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(NgxIndexedDBService, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: undefined,\n      decorators: [{\n        type: Inject,\n        args: [CONFIG_TOKEN]\n      }]\n    }, {\n      type: undefined,\n      decorators: [{\n        type: Inject,\n        args: [PLATFORM_ID]\n      }]\n    }];\n  }, null);\n})();\n\nclass NgxIndexedDBModule {\n  static forRoot(dbConfig) {\n    return {\n      ngModule: NgxIndexedDBModule,\n      providers: [NgxIndexedDBService, {\n        provide: CONFIG_TOKEN,\n        useValue: dbConfig\n      }]\n    };\n  }\n\n}\n\nNgxIndexedDBModule.ɵfac = function NgxIndexedDBModule_Factory(t) {\n  return new (t || NgxIndexedDBModule)();\n};\n\nNgxIndexedDBModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n  type: NgxIndexedDBModule\n});\nNgxIndexedDBModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n  imports: [[CommonModule]]\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(NgxIndexedDBModule, [{\n    type: NgModule,\n    args: [{\n      declarations: [],\n      imports: [CommonModule]\n    }]\n  }], null, null);\n})();\n/**\n * Generated bundle index. Do not edit.\n */\n\n\nexport { CONFIG_TOKEN, DBMode, NgxIndexedDBModule, NgxIndexedDBService };","map":{"version":3,"sources":["C:/Users/mique/DAW2/M14/PROJECTE_ANGULAR/Videojocs/node_modules/ngx-indexed-db/fesm2015/ngx-indexed-db.mjs"],"names":["i0","InjectionToken","PLATFORM_ID","Injectable","Inject","NgModule","isPlatformBrowser","CommonModule","__awaiter","Observable","from","combineLatest","Subject","take","openDatabase","indexedDB","dbName","version","upgradeCallback","Promise","resolve","reject","request","open","db","onsuccess","event","result","onerror","error","onupgradeneeded","CreateObjectStore","storeSchemas","migrationFactory","database","target","forEach","storeSchema","objectStoreNames","contains","store","objectStore","createObjectStore","storeConfig","schema","createIndex","name","keypath","options","storeMigrations","Object","keys","map","k","parseInt","filter","v","oldVersion","sort","a","b","transaction","close","e","DeleteObjectStore","storeName","Error","obs","newVersion","deleteObjectStore","console","log","next","complete","validateStoreName","validateBeforeTransaction","createTransaction","trans","dbMode","onabort","abort","optionsGenerator","type","DBMode","CONFIG_TOKEN","NgxIndexedDBService","constructor","dbConfig","platformId","isBrowser","window","mozIndexedDB","webkitIndexedDB","msIndexedDB","objectStoresMeta","then","process","env","NODE_ENV","warn","add","value","key","readwrite","Boolean","evt","getRequest","get","catch","bulkAdd","values","promises","results","resolve1","reject1","all","reason","bulkDelete","delete","oncomplete","getAll","pipe","subscribe","newValues","getByKey","readonly","bulkGet","observables","getByID","id","getByIndex","indexName","index","ResultAll","update","put","updateByKey","newValue","deleteByKey","clear","deleteDatabase","deleteDBRequest","onblocked","openCursor","keyRange","undefined","openCursorByIndex","mode","getAllByIndex","data","cursor","push","continue","getAllKeysByIndex","openKeyCursor","primaryKey","count","ɵfac","ɵprov","decorators","args","NgxIndexedDBModule","forRoot","ngModule","providers","provide","useValue","ɵmod","ɵinj","declarations","imports"],"mappings":"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","sourcesContent":["import * as i0 from '@angular/core';\nimport { InjectionToken, PLATFORM_ID, Injectable, Inject, NgModule } from '@angular/core';\nimport { isPlatformBrowser, CommonModule } from '@angular/common';\nimport { __awaiter } from 'tslib';\nimport { Observable, from, combineLatest, Subject } from 'rxjs';\nimport { take } from 'rxjs/operators';\n\nfunction openDatabase(indexedDB, dbName, version, upgradeCallback) {\n    return new Promise((resolve, reject) => {\n        if (!indexedDB) {\n            reject('IndexedDB not available');\n        }\n        const request = indexedDB.open(dbName, version);\n        let db;\n        request.onsuccess = (event) => {\n            db = request.result;\n            resolve(db);\n        };\n        request.onerror = (event) => {\n            reject(`IndexedDB error: ${request.error}`);\n        };\n        if (typeof upgradeCallback === 'function') {\n            request.onupgradeneeded = (event) => {\n                upgradeCallback(event, db);\n            };\n        }\n    });\n}\nfunction CreateObjectStore(indexedDB, dbName, version, storeSchemas, migrationFactory) {\n    if (!indexedDB) {\n        return;\n    }\n    const request = indexedDB.open(dbName, version);\n    request.onupgradeneeded = (event) => {\n        const database = event.target.result;\n        storeSchemas.forEach((storeSchema) => {\n            if (!database.objectStoreNames.contains(storeSchema.store)) {\n                const objectStore = database.createObjectStore(storeSchema.store, storeSchema.storeConfig);\n                storeSchema.storeSchema.forEach((schema) => {\n                    objectStore.createIndex(schema.name, schema.keypath, schema.options);\n                });\n            }\n        });\n        const storeMigrations = migrationFactory && migrationFactory();\n        if (storeMigrations) {\n            Object.keys(storeMigrations)\n                .map((k) => parseInt(k, 10))\n                .filter((v) => v > event.oldVersion)\n                .sort((a, b) => a - b)\n                .forEach((v) => {\n                storeMigrations[v](database, request.transaction);\n            });\n        }\n        database.close();\n    };\n    request.onsuccess = (e) => {\n        e.target.result.close();\n    };\n}\nfunction DeleteObjectStore(dbName, version, storeName) {\n    if (!dbName || !version || !storeName) {\n        throw Error('Params: \"dbName\", \"version\", \"storeName\" are mandatory.');\n    }\n    return new Observable((obs) => {\n        try {\n            const newVersion = version + 1;\n            const request = indexedDB.open(dbName, newVersion);\n            request.onupgradeneeded = (event) => {\n                const database = event.target.result;\n                database.deleteObjectStore(storeName);\n                database.close();\n                console.log('onupgradeneeded');\n                obs.next(true);\n                obs.complete();\n            };\n            request.onerror = (e) => obs.error(e);\n        }\n        catch (error) {\n            obs.error(error);\n        }\n    });\n}\n\nfunction validateStoreName(db, storeName) {\n    return db.objectStoreNames.contains(storeName);\n}\nfunction validateBeforeTransaction(db, storeName, reject) {\n    if (!db) {\n        reject('You need to use the openDatabase function to create a database before you query it!');\n    }\n    if (!validateStoreName(db, storeName)) {\n        reject(`objectStore does not exists: ${storeName}`);\n    }\n}\nfunction createTransaction(db, options) {\n    const trans = db.transaction(options.storeName, options.dbMode);\n    trans.onerror = options.error;\n    trans.onabort = options.abort;\n    return trans;\n}\nfunction optionsGenerator(type, storeName, reject, resolve) {\n    return {\n        storeName,\n        dbMode: type,\n        error: (e) => {\n            reject(e);\n        },\n        abort: (e) => {\n            reject(e);\n        },\n    };\n}\n\nvar DBMode;\n(function (DBMode) {\n    DBMode[\"readonly\"] = \"readonly\";\n    DBMode[\"readwrite\"] = \"readwrite\";\n})(DBMode || (DBMode = {}));\nconst CONFIG_TOKEN = new InjectionToken(null);\n\nclass NgxIndexedDBService {\n    constructor(dbConfig, platformId) {\n        this.dbConfig = dbConfig;\n        this.platformId = platformId;\n        if (!dbConfig.name) {\n            throw new Error('NgxIndexedDB: Please, provide the dbName in the configuration');\n        }\n        if (!dbConfig.version) {\n            throw new Error('NgxIndexedDB: Please, provide the db version in the configuration');\n        }\n        this.isBrowser = isPlatformBrowser(this.platformId);\n        if (this.isBrowser) {\n            this.indexedDB =\n                window.indexedDB ||\n                    window.mozIndexedDB ||\n                    window.webkitIndexedDB ||\n                    window.msIndexedDB;\n            CreateObjectStore(this.indexedDB, dbConfig.name, dbConfig.version, dbConfig.objectStoresMeta, dbConfig.migrationFactory);\n            openDatabase(this.indexedDB, dbConfig.name).then((db) => {\n                if (db.version !== dbConfig.version) {\n                    if (process.env.NODE_ENV !== 'production') {\n                        console.warn(`\n            Your DB Config doesn't match the most recent version of the DB with name ${this.dbConfig.name}, please update it\n            DB current version: ${db.version};\n            Your configuration: ${dbConfig.version};\n            `);\n                        console.warn(`Using latest version ${db.version}`);\n                    }\n                    this.dbConfig.version = db.version;\n                }\n            });\n        }\n    }\n    /**\n     * Allows to crate a new object store ad-hoc\n     * @param storeName The name of the store to be created\n     * @param migrationFactory The migration factory if exists\n     */\n    createObjectStore(storeSchema, migrationFactory) {\n        const storeSchemas = [storeSchema];\n        CreateObjectStore(this.indexedDB, this.dbConfig.name, ++this.dbConfig.version, storeSchemas, migrationFactory);\n    }\n    /**\n     * Adds new entry in the store and returns its key\n     * @param storeName The name of the store to add the item\n     * @param value The entry to be added\n     * @param key The optional key for the entry\n     */\n    add(storeName, value, key) {\n        return new Observable((obs) => {\n            openDatabase(this.indexedDB, this.dbConfig.name, this.dbConfig.version)\n                .then((db) => {\n                const transaction = createTransaction(db, optionsGenerator(DBMode.readwrite, storeName, obs.error));\n                const objectStore = transaction.objectStore(storeName);\n                const request = Boolean(key) ? objectStore.add(value, key) : objectStore.add(value);\n                request.onsuccess = (evt) => __awaiter(this, void 0, void 0, function* () {\n                    const result = evt.target.result;\n                    const getRequest = objectStore.get(result);\n                    getRequest.onsuccess = (event) => {\n                        obs.next(event.target.result);\n                        obs.complete();\n                    };\n                });\n            })\n                .catch((error) => obs.error(error));\n        });\n    }\n    /**\n     * Adds new entries in the store and returns its key\n     * @param storeName The name of the store to add the item\n     * @param values The entries to be added containing optional key attribute\n     */\n    bulkAdd(storeName, values) {\n        const promises = new Promise((resolve, reject) => {\n            openDatabase(this.indexedDB, this.dbConfig.name, this.dbConfig.version)\n                .then((db) => {\n                const transaction = createTransaction(db, optionsGenerator(DBMode.readwrite, storeName, resolve, reject));\n                const objectStore = transaction.objectStore(storeName);\n                const results = values.map((value) => {\n                    return new Promise((resolve1, reject1) => {\n                        const key = value.key;\n                        delete value.key;\n                        const request = Boolean(key)\n                            ? objectStore.add(value, key)\n                            : objectStore.add(value);\n                        request.onsuccess = (evt) => {\n                            const result = evt.target.result;\n                            resolve1(result);\n                        };\n                    });\n                });\n                resolve(Promise.all(results));\n            }).catch((reason) => reject(reason));\n        });\n        return from(promises);\n    }\n    /**\n     * Delete entries in the store and returns current entries in the store\n     * @param storeName The name of the store to add the item\n     * @param keys The keys to be deleted\n     */\n    bulkDelete(storeName, keys) {\n        const promises = keys.map((key) => {\n            return new Promise((resolve, reject) => {\n                openDatabase(this.indexedDB, this.dbConfig.name, this.dbConfig.version)\n                    .then((db) => {\n                    const transaction = createTransaction(db, optionsGenerator(DBMode.readwrite, storeName, reject, resolve));\n                    const objectStore = transaction.objectStore(storeName);\n                    objectStore.delete(key);\n                    transaction.oncomplete = () => {\n                        this.getAll(storeName)\n                            .pipe(take(1))\n                            .subscribe((newValues) => {\n                            resolve(newValues);\n                        });\n                    };\n                })\n                    .catch((reason) => reject(reason));\n            });\n        });\n        return from(Promise.all(promises));\n    }\n    /**\n     * Returns entry by key.\n     * @param storeName The name of the store to query\n     * @param key The entry key\n     */\n    getByKey(storeName, key) {\n        return new Observable((obs) => {\n            openDatabase(this.indexedDB, this.dbConfig.name, this.dbConfig.version)\n                .then((db) => {\n                const transaction = createTransaction(db, optionsGenerator(DBMode.readonly, storeName, obs.error));\n                const objectStore = transaction.objectStore(storeName);\n                const request = objectStore.get(key);\n                request.onsuccess = (event) => {\n                    obs.next(event.target.result);\n                    obs.complete();\n                };\n                request.onerror = (event) => {\n                    obs.error(event);\n                };\n            })\n                .catch((error) => obs.error(error));\n        });\n    }\n    /**\n     * Retrieve multiple entries in the store\n     * @param storeName The name of the store to retrieve the items\n     * @param keys The ids entries to be retrieve\n     */\n    bulkGet(storeName, keys) {\n        const observables = keys.map((key) => this.getByKey(storeName, key));\n        return new Observable((obs) => {\n            combineLatest(observables).subscribe((values) => {\n                obs.next(values);\n                obs.complete();\n            });\n        });\n    }\n    /**\n     * Returns entry by id.\n     * @param storeName The name of the store to query\n     * @param id The entry id\n     */\n    getByID(storeName, id) {\n        return new Observable((obs) => {\n            openDatabase(this.indexedDB, this.dbConfig.name, this.dbConfig.version)\n                .then((db) => {\n                validateBeforeTransaction(db, storeName, obs.error);\n                const transaction = createTransaction(db, optionsGenerator(DBMode.readonly, storeName, obs.error, obs.next));\n                const objectStore = transaction.objectStore(storeName);\n                const request = objectStore.get(id);\n                request.onsuccess = (event) => {\n                    obs.next(event.target.result);\n                };\n            })\n                .catch((error) => obs.error(error));\n        });\n    }\n    /**\n     * Returns entry by index.\n     * @param storeName The name of the store to query\n     * @param indexName The index name to filter\n     * @param key The entry key.\n     */\n    getByIndex(storeName, indexName, key) {\n        return new Observable((obs) => {\n            openDatabase(this.indexedDB, this.dbConfig.name, this.dbConfig.version)\n                .then((db) => {\n                validateBeforeTransaction(db, storeName, obs.error);\n                const transaction = createTransaction(db, optionsGenerator(DBMode.readonly, storeName, obs.error));\n                const objectStore = transaction.objectStore(storeName);\n                const index = objectStore.index(indexName);\n                const request = index.get(key);\n                request.onsuccess = (event) => {\n                    obs.next(event.target.result);\n                    obs.complete();\n                };\n            })\n                .catch((reason) => obs.error(reason));\n        });\n    }\n    /**\n     * Return all elements from one store\n     * @param storeName The name of the store to select the items\n     */\n    getAll(storeName) {\n        return new Observable((obs) => {\n            openDatabase(this.indexedDB, this.dbConfig.name, this.dbConfig.version)\n                .then((db) => {\n                validateBeforeTransaction(db, storeName, obs.error);\n                const transaction = createTransaction(db, optionsGenerator(DBMode.readonly, storeName, obs.error, obs.next));\n                const objectStore = transaction.objectStore(storeName);\n                const request = objectStore.getAll();\n                request.onerror = (evt) => {\n                    obs.error(evt);\n                };\n                request.onsuccess = ({ target: { result: ResultAll } }) => {\n                    obs.next(ResultAll);\n                    obs.complete();\n                };\n            })\n                .catch((error) => obs.error(error));\n        });\n    }\n    /**\n     * Returns all items from the store after update.\n     * @param storeName The name of the store to update\n     * @param value The new value for the entry\n     * @param key The key of the entry to update if exists\n     */\n    update(storeName, value, key) {\n        return new Observable((obs) => {\n            openDatabase(this.indexedDB, this.dbConfig.name, this.dbConfig.version)\n                .then((db) => {\n                validateBeforeTransaction(db, storeName, obs.error);\n                const transaction = createTransaction(db, optionsGenerator(DBMode.readwrite, storeName, obs.error));\n                const objectStore = transaction.objectStore(storeName);\n                transaction.oncomplete = () => {\n                    this.getAll(storeName)\n                        .pipe(take(1))\n                        .subscribe((newValues) => {\n                        obs.next(newValues);\n                        obs.complete();\n                    });\n                };\n                key ? objectStore.put(value, key) : objectStore.put(value);\n            })\n                .catch((reason) => obs.error(reason));\n        });\n    }\n    /**\n     * Returns the item you updated from the store after the update.\n     * @param storeName The name of the store to update\n     * @param value The new value for the entry\n     * @param key The key of the entry to update\n     */\n    updateByKey(storeName, value, key) {\n        return new Observable((obs) => {\n            openDatabase(this.indexedDB, this.dbConfig.name, this.dbConfig.version)\n                .then((db) => {\n                validateBeforeTransaction(db, storeName, obs.error);\n                const transaction = createTransaction(db, optionsGenerator(DBMode.readwrite, storeName, obs.error));\n                const objectStore = transaction.objectStore(storeName);\n                transaction.oncomplete = () => {\n                    this.getByKey(storeName, key)\n                        .pipe(take(1))\n                        .subscribe((newValue) => {\n                        obs.next(newValue);\n                        obs.complete();\n                    });\n                };\n                objectStore.put(value, key);\n            })\n                .catch((reason) => obs.error(reason));\n        });\n    }\n    /**\n     * Returns all items from the store after delete.\n     * @param storeName The name of the store to have the entry deleted\n     * @param key The key of the entry to be deleted\n     */\n    delete(storeName, key) {\n        return new Observable((obs) => {\n            openDatabase(this.indexedDB, this.dbConfig.name, this.dbConfig.version)\n                .then((db) => {\n                validateBeforeTransaction(db, storeName, obs.error);\n                const transaction = createTransaction(db, optionsGenerator(DBMode.readwrite, storeName, obs.error));\n                const objectStore = transaction.objectStore(storeName);\n                objectStore.delete(key);\n                transaction.oncomplete = () => {\n                    this.getAll(storeName)\n                        .pipe(take(1))\n                        .subscribe((newValues) => {\n                        obs.next(newValues);\n                        obs.complete();\n                    });\n                };\n            })\n                .catch((reason) => obs.error(reason));\n        });\n    }\n    /**\n     * Returns true from the store after a successful delete.\n     * @param storeName The name of the store to have the entry deleted\n     * @param key The key of the entry to be deleted\n     */\n    deleteByKey(storeName, key) {\n        return new Observable((obs) => {\n            openDatabase(this.indexedDB, this.dbConfig.name, this.dbConfig.version)\n                .then((db) => {\n                validateBeforeTransaction(db, storeName, obs.error);\n                const transaction = createTransaction(db, optionsGenerator(DBMode.readwrite, storeName, obs.error));\n                const objectStore = transaction.objectStore(storeName);\n                transaction.oncomplete = () => {\n                    obs.next(true);\n                    obs.complete();\n                };\n                objectStore.delete(key);\n            })\n                .catch((reason) => obs.error(reason));\n        });\n    }\n    /**\n     * Returns true if successfully delete all entries from the store.\n     * @param storeName The name of the store to have the entries deleted\n     */\n    clear(storeName) {\n        return new Observable((obs) => {\n            openDatabase(this.indexedDB, this.dbConfig.name, this.dbConfig.version)\n                .then((db) => {\n                validateBeforeTransaction(db, storeName, obs.error);\n                const transaction = createTransaction(db, optionsGenerator(DBMode.readwrite, storeName, obs.error));\n                const objectStore = transaction.objectStore(storeName);\n                objectStore.clear();\n                transaction.oncomplete = () => {\n                    obs.next(true);\n                    obs.complete();\n                };\n            })\n                .catch((reason) => obs.error(reason));\n        });\n    }\n    /**\n     * Returns true if successfully delete the DB.\n     */\n    deleteDatabase() {\n        return new Observable((obs) => {\n            openDatabase(this.indexedDB, this.dbConfig.name, this.dbConfig.version)\n                .then((db) => __awaiter(this, void 0, void 0, function* () {\n                yield db.close();\n                const deleteDBRequest = this.indexedDB.deleteDatabase(this.dbConfig.name);\n                deleteDBRequest.onsuccess = () => {\n                    obs.next(true);\n                    obs.complete();\n                };\n                deleteDBRequest.onerror = (error) => obs.error(error);\n                deleteDBRequest.onblocked = () => {\n                    throw new Error(`Unable to delete database because it's blocked`);\n                };\n            }))\n                .catch((error) => obs.error(error));\n        });\n    }\n    /**\n     * Returns the open cursor event\n     * @param storeName The name of the store to have the entries deleted\n     * @param keyRange The key range which the cursor should be open on\n     */\n    openCursor(storeName, keyRange) {\n        return new Observable((obs) => {\n            openDatabase(this.indexedDB, this.dbConfig.name, this.dbConfig.version)\n                .then((db) => {\n                validateBeforeTransaction(db, storeName, obs.error);\n                const transaction = createTransaction(db, optionsGenerator(DBMode.readonly, storeName, obs.error));\n                const objectStore = transaction.objectStore(storeName);\n                const request = keyRange === undefined ? objectStore.openCursor() : objectStore.openCursor(keyRange);\n                request.onsuccess = (event) => {\n                    obs.next(event);\n                    obs.complete();\n                };\n            })\n                .catch((reason) => obs.error(reason));\n        });\n    }\n    /**\n     * Open a cursor by index filter.\n     * @param storeName The name of the store to query.\n     * @param indexName The index name to filter.\n     * @param keyRange The range value and criteria to apply on the index.\n     */\n    openCursorByIndex(storeName, indexName, keyRange, mode = DBMode.readonly) {\n        const obs = new Subject();\n        openDatabase(this.indexedDB, this.dbConfig.name, this.dbConfig.version)\n            .then((db) => {\n            validateBeforeTransaction(db, storeName, (reason) => {\n                obs.error(reason);\n            });\n            const transaction = createTransaction(db, optionsGenerator(mode, storeName, (reason) => {\n                obs.error(reason);\n            }, () => {\n                obs.next();\n            }));\n            const objectStore = transaction.objectStore(storeName);\n            const index = objectStore.index(indexName);\n            const request = index.openCursor(keyRange);\n            request.onsuccess = (event) => {\n                obs.next(event);\n            };\n        })\n            .catch((reason) => obs.error(reason));\n        return obs;\n    }\n    /**\n     * Returns all items by an index.\n     * @param storeName The name of the store to query\n     * @param indexName The index name to filter\n     * @param keyRange  The range value and criteria to apply on the index.\n     */\n    getAllByIndex(storeName, indexName, keyRange) {\n        const data = [];\n        return new Observable((obs) => {\n            openDatabase(this.indexedDB, this.dbConfig.name, this.dbConfig.version)\n                .then((db) => {\n                validateBeforeTransaction(db, storeName, obs.error);\n                const transaction = createTransaction(db, optionsGenerator(DBMode.readonly, storeName, obs.error));\n                const objectStore = transaction.objectStore(storeName);\n                const index = objectStore.index(indexName);\n                const request = index.openCursor(keyRange);\n                request.onsuccess = (event) => {\n                    const cursor = event.target.result;\n                    if (cursor) {\n                        data.push(cursor.value);\n                        cursor.continue();\n                    }\n                    else {\n                        obs.next(data);\n                        obs.complete();\n                    }\n                };\n            })\n                .catch((reason) => obs.error(reason));\n        });\n    }\n    /**\n     * Returns all primary keys by an index.\n     * @param storeName The name of the store to query\n     * @param indexName The index name to filter\n     * @param keyRange  The range value and criteria to apply on the index.\n     */\n    getAllKeysByIndex(storeName, indexName, keyRange) {\n        const data = [];\n        return new Observable((obs) => {\n            openDatabase(this.indexedDB, this.dbConfig.name, this.dbConfig.version)\n                .then((db) => {\n                validateBeforeTransaction(db, storeName, obs.error);\n                const transaction = createTransaction(db, optionsGenerator(DBMode.readonly, storeName, obs.error));\n                const objectStore = transaction.objectStore(storeName);\n                const index = objectStore.index(indexName);\n                const request = index.openKeyCursor(keyRange);\n                request.onsuccess = (event) => {\n                    const cursor = event.target.result;\n                    if (cursor) {\n                        data.push({ primaryKey: cursor.primaryKey, key: cursor.key });\n                        cursor.continue();\n                    }\n                    else {\n                        obs.next(data);\n                        obs.complete();\n                    }\n                };\n            })\n                .catch((reason) => obs.error(reason));\n        });\n    }\n    /**\n     * Returns the number of rows in a store.\n     * @param storeName The name of the store to query\n     * @param keyRange  The range value and criteria to apply.\n     */\n    count(storeName, keyRange) {\n        return new Observable((obs) => {\n            openDatabase(this.indexedDB, this.dbConfig.name, this.dbConfig.version)\n                .then((db) => {\n                validateBeforeTransaction(db, storeName, obs.error);\n                const transaction = createTransaction(db, optionsGenerator(DBMode.readonly, storeName, obs.error));\n                const objectStore = transaction.objectStore(storeName);\n                const request = objectStore.count(keyRange);\n                request.onerror = (e) => obs.error(e);\n                request.onsuccess = (e) => {\n                    obs.next(e.target.result);\n                    obs.complete();\n                };\n            })\n                .catch((reason) => obs.error(reason));\n        });\n    }\n    /**\n     * Delete the store by name.\n     * @param storeName The name of the store to query\n     */\n    deleteObjectStore(storeName) {\n        return DeleteObjectStore(this.dbConfig.name, ++this.dbConfig.version, storeName);\n    }\n}\nNgxIndexedDBService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"13.2.0\", ngImport: i0, type: NgxIndexedDBService, deps: [{ token: CONFIG_TOKEN }, { token: PLATFORM_ID }], target: i0.ɵɵFactoryTarget.Injectable });\nNgxIndexedDBService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"13.2.0\", ngImport: i0, type: NgxIndexedDBService });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"13.2.0\", ngImport: i0, type: NgxIndexedDBService, decorators: [{\n            type: Injectable\n        }], ctorParameters: function () {\n        return [{ type: undefined, decorators: [{\n                        type: Inject,\n                        args: [CONFIG_TOKEN]\n                    }] }, { type: undefined, decorators: [{\n                        type: Inject,\n                        args: [PLATFORM_ID]\n                    }] }];\n    } });\n\nclass NgxIndexedDBModule {\n    static forRoot(dbConfig) {\n        return {\n            ngModule: NgxIndexedDBModule,\n            providers: [NgxIndexedDBService, { provide: CONFIG_TOKEN, useValue: dbConfig }]\n        };\n    }\n}\nNgxIndexedDBModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"13.2.0\", ngImport: i0, type: NgxIndexedDBModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });\nNgxIndexedDBModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: \"12.0.0\", version: \"13.2.0\", ngImport: i0, type: NgxIndexedDBModule, imports: [CommonModule] });\nNgxIndexedDBModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: \"12.0.0\", version: \"13.2.0\", ngImport: i0, type: NgxIndexedDBModule, imports: [[CommonModule]] });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"13.2.0\", ngImport: i0, type: NgxIndexedDBModule, decorators: [{\n            type: NgModule,\n            args: [{\n                    declarations: [],\n                    imports: [CommonModule]\n                }]\n        }] });\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { CONFIG_TOKEN, DBMode, NgxIndexedDBModule, NgxIndexedDBService };\n"]},"metadata":{},"sourceType":"module"}